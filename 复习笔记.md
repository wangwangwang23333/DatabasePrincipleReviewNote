### Chapter 2: Intro to Relational Model

#### domain

- the set of allowed values for each attribute is called the **domain.**

- Attribute types are required to be **atomic.**

- **null** value is a member of every domain.

#### Relation Schema and Instance

- relation r (a table) 
- relation schema R=($$R_1,R_2,...R_n$$)

#### Relations are unordered

#### Database

A database consists of multiple **relations**

#### Keys

1. Superkey: K are sufficient to identify a unique tuple of each possible relation r(R)
2. Candidate key: the minimal of Superkey
3. Primary key: One of the candidate keys
4. Foreign key constrain: Value in one relation must appear in another
   1. **Referencing **relation
   2. **Referenced** relation

#### University Database

![image-20210621225041712](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210621225041712.png)

#### Relational Query language

- **Selection** of tuples: $$\sigma $$
- **Projection** on columns: $$\Pi$$
- **Joining** two relations: Cartesian product X
- **Union** of two relations: $$\cap$$
- **Set difference** of two relations: -
- **Set intersection** of two relations: $$\cup$$
- Natural join: $$\Join$$



### Chapter 3: Introduction to SQL

SQL: Renamed Structured Query Language

#### Data Definition Language

The SQL **DDL** allows:

- The schema for each relation
- The domain of values associate with each attribute
- Integrity constrains
- and so on

#### Domain Types

- char(n)
- varchar(n)
- int.
- smallint.
- numeric(p,d)
- float(n)

#### Create Table Construct

**Integrity Constrains**

- not null
- primary key($$A_1,A_2,...A_n$$)
- foreign key($$A_m,...A_n$$) references r

**Example**

create table instructor(

​	ID char(5),

​	name varchar(20) not null,	

​	dept_name varchar(20),

​	salary numeric(8,2),

​	primary key(ID),

​	foreign key(dept_name) references department

)

**Notion**

**not null** $$\in$$ **primary key** 

#### Drop and Alter

- drop table: Delete the table and its content
- delete from
- alter table
  - alter table r add A D
  - alter table r drop A

#### Basic Query Structure

The SQL **data-manipulation language**(DML) provides the ability to **query** information, and **insert**, **delete** and **update** tuples

**Notion**

The result of an SQL query is a relation

#### Select

- **distinct** can eliminate the duplicates:

  **select distinct** dept_name from instructor

- **all** specifies that duplicates not be removed:

  **select all** dept_name from instructor

- Asterisk(*) means all attribute: select * from instructor

- **select** can constrain arithmetic expressions, like:

  select ID, name, salary/12 from instructor

#### Where

logical connectives: **and**, **or**, **not**

#### From

select * from instructor, teaches

#### Joins

**where** and **from**

#### Natural join

matches tuples with the same values for all common attributes, and retains only **one copy** of each common attribute

**Example**

select name, course_id from instructor, teaches where instructor.ID = teaches.ID

is equal to

select name, course_id from instructor natural join teaches

**Notion**

unrelated attributes with same name which get equated incorrectly

#### Rename operation

oldname newname

**Example**

select T.name from instructor T, instructor S

where T.salary>S.salary and S.dept_name='Comp.Sci.'

#### String operations

**like** use patterns with two characters:

- %: any substring
- _: any character

**Example**

1. Find names including "dar";

   select name from instructor where name like '%dar%'

2. Match the string '100%':

   like '100 \%' escape '\'

#### Ordering the display of tuples

**order by** $$A_m,...A_n$$ (desc)

#### Where clause predicates

- between
- tuple comparision: where (a,b) = (c,d)

#### Duplicates

relations $$r_1$$ and $$ r_2$$:

- $$\sigma_{\theta}(r_1): $$ If there are $$c_1$$ copies of tuple $$t_1$$ in $$r_1$$, and $$t_1$$ satisfies selections $$\sigma_{\theta}$$, then there are $$c_1$$ copies of $$t_1$$ in $$\sigma_{\theta}(r_1)$$ 
- $$\Pi_A(r_1)$$: same to the above
- $$r_1 \times r_2$$: $$c_1,c_2 \to c_1 \times c_2$$ copies

#### Set operations

**union**, **intersect** and **except** eliminate duplicates.

To remain, use **union all**, **intersect all** and **except all**.

Suppose a tuple occurs m times in r and n times in s, then it occurs:

- m+n times in r **union all** s
- min(m,n) times in r **intersect all** s
- max(0,m-n) times in r **except all** s

#### Null values

- Any arithmetic expression involving **null** is **null**

  Example: 5 + null returns null

- **is null** can be used to check for null values

- Three logic: Unknown means either true or false

- Result of **where ** clause predicate is treated as false if it evaluates to unknown

#### Aggregate Functions

- avg
- min
- max
- sum
- count

##### Group by

Attributes in **select** clause outside of aggregate functions must appear in **group by** list

##### Having

**Having** is applied after the formation of groups whereas **where** are applied before forming groups

**Example**

select dept_name, avg(salary) from instructor group by dept_name having avg(salary)> 42000

##### Null values

- Have values not only null:
  - Other aggregate functions: ignore null values
  - count(*): Not ignore
- Only have null:
  - count: return 0
  - Other aggregate functions: return null

#### Nested subqueries

**Example**

Find course offered in Fall 2009 and Spring 2010

select distinct course_id

from section

where semester='Fall' and year=2009 and

​	course_id in 

​	(select course_id from section where semester='Spring' and year=2010)

#### Set comparison

##### some

select distinct T.name

from instructor T, instructor S

where T.salary> S.salary and S.dept_name='Biology'

**is equal to** query using > **some**

- = some $$\equiv$$ in
- ≠ some $$ \not \equiv$$ not in

##### all

where salary > all(...)

- ≠ all $$\equiv$$ not in
- = all $$ \not \equiv$$ in

#### exists

**exists** r  $$\equiv$$ $$r \not = \empty$$

**not exists ** r   $$\equiv$$ $$r  = \empty$$

##### Correlation variables

select course_id from section S

where semester='Fall' and year=2009 and exists(

select * from section T

where semester='Spring' and year=2010

and S.course_id=T.course_id

)

##### Not exists

Find students who have taken all courses offered in the Biology department.

select distinct S.ID, S.name

from student S

where **not exists**(

(select course_id from course where dept_name='Biology')

**except**

(select T.course_id from takes T where S.ID = T.ID)

)

**Notion**

$$X-Y=\empty \equiv X \subseteq Y$$

#### Test Absence of Duplicates

**where unique**(...)

#### Subqueries in the From Clause

select dept_name, avg_salary

from (select dept_name, avg(salary) avg_salary

​			 from instructor

​			 group by dept_name)

where avg_aslary>42000

#### With 

Define a temporary view

**Example**

with max_budget(value) as (select max(budget) from department)

select budget from department,max_budget

where deparment.budget=max_budget.budget

#### Scalar subquery

Must return a single value

**Example**

select dept_name,

​			(select count(*) from instructor where 

​			deparment.dept_name=instructor.dept_name)

from department

#### Deletion

1. Delete all instructors:

   **delete from** instructor

2. Delete all instructors from the Finance department:

   **delete from** instructor

   **where** dept_name='Finance'

**Notion**

delete from instructor where salary<(select avg(salary) from instructor);

causes problem

#### Insertion

insert into course

values('CS-437','Database System','Comp. Sci.',4);

**equal to**

insert into course(course_id,title,dept_name,credits)

values('CS-437','Database System','Comp. Sci.',4);

##### Insertion(Cont.)

**insert into** table1 **select ... from** table2

The **select from where** statement is evaluated fully before any of its results are inserted into the relation.

#### Update

**update** instructor

​	**set** salary=salary*1.03

​	**where** salary>100000;

##### case

**update** instructor

​	**set** salary= **case**

​						**when** salary<=100000 **then** salary*1.05

​						**else** salary*1.03

​						**end**

##### Scalar subqueries

**Example1**

*Recompute and update tot_creds value for all students.*

update student S

​	set tot_cred=(select sum(credits)

​							from takes natural join course

​							where S.ID=takes.ID and takes.grade!='F'

​								and takes.grade is not null)

**Example2**

*Set tot_reds to null for students who have not taken any course.*

Instead of **sum**(credits), use:

case 

​		when sum(credits) is not null then sum(credits)

​		else 0

end

### Chapter4: Intermediate SQL

#### Joined Relations

**Join operations** take two relations and return as a result another relation.

- Join types:
  - inner join
  - left outer join
  - right outer join
  - full outer join
- Join conditions:
  - natural
  - on <predicate>
  - using $$(A_1,A_2,...A_n)$$

#### Outer join

An extension of the join operation that avoids loss of information.

**left outer join**

**right outer join**

#### Example

1. course **inner join** prereq **on** course.course_id=prereq.course_id
2. course **left outer join** prereq **on** course.course_id=prereq.course_id
3. course **natural right outer join** prereq
4. course **full outer join** prereq **using**(course_id)

#### Views

Any relation that is not of the conceptual model but is made visuable to a user as a "virtual relation".

#### View Definition

**create view** v **as** <query expression>

#### Example

- A view of instructors without their salary:

  **create** view faculty **as**

  ​	**select** ID,name,dept_name **from** instructor

- Find all instructors in the Biology deparment:

  **select** name **from** faculty **where** dept_name='Biology'

#### View defined using other views

One view may be used in the expression defining another view.

- depend directly
- depend
- recursive

#### Update of a view

**insert into** faculty **values** ('30765','Green','Music');

The insertion must be presented by the insertion of the tuple ('30765','Green','Music',null) into the *instructor* relation.

**Notion**

Most SQL implements allow updates only on simple views

- The **from** clause has only one relation
- The **select** clause contains only attribute names of the relation, and does not have any expressions, aggregates, or **distinct** specification
- Any attribute not listed in the **select** clause can be set to null

#### Materialized Views

Create a physical table containing all the tuples in the result of the query defining the view

Need to **maintain** the view

#### Transactions

- begin implicitly
- end by **commit work** or **rollback work**

#### Integrity Constraints

On a Single Relation

- not null
- primary key
- unique
- check(P), where P is a predicate

#### Referential Integrity

**foreign key**(dept_name) **references** deparment

​	**on delete cascade**

​	**on update cascade**,

#### Complex Check Clause

trigger?

#### Index Creation

**create index** studentID_index **on** student(ID)

**Example**

select * from student where ID='12345'

#### User-Defined Types

**create type** Dollars **as numeric**(12,2) **final**

#### Domains

**create domain** person_name char(20) **not null**

#### Authorization

1. Forms of authorization on parts of the database:
   1. Read
   2. Insert
   3. Update
   4. Delete
2. Forms of authorization to modify the database schema
   1. Index
   2. Resources
   3. Alteration
   4. Drop

#### Authorization Specification in SQL

**grant** <privilege list>

**on** <relation name of view name> **to** <user list>

- <user list> is:
  - a user-id
  - public
  - a role
- Granting a privilege on a view does not imply granting any privileges on the underlying relations

#### Privileges in SQL

- select
- insert
- update 
- delete
- all privileges

#### Revoke Authorization

**revoke** <privilege list>(**all**)

**on** <relation name of view name> **from** <user list>

#### Roles

create role instructor;

grant select on takes to instructor;

grant instructor to Amit;

#### Other authorization Features

**references** privilege to create foreign key

- cascade
- restrict



### Chapter 5: Advanced SQL

#### SQL Functions

- Define a function that, given the name of a department, returns the count of the number of instructors in that department.

  **create function** dept_count(dept_name **varchar**(20))

  **returns integer**

  **begin**

  ​	**declare** d_count **integer**;

  ​	**select count**(*) into d_count

  ​	**from** instructor **where** instructor.dept_name = dept_name;

  ​	**return** d_count;

  **end**

- Find the department name and budget of all departments with more than 12 instructors.

  **select** dept_name,budget **from** department 

  **where** dept_count(dept_name)>12

#### Table Functions

... returns table(ID varchar(5),name varchar(20))...

select * from table(...)

#### SQL Procedures

1.Declare:

**create procedure** dept_count_proc(**in** dept_name **varchar**(20),**out** d_count **integer**)

**begin**

​	select count(*) into d_count

​	from instructor where instructor.dept_name=dept_coint_proc.dept_name

**end**

2.Use:

declare d_count integer;

call dept_count_proc('Physics',d_count);

#### Triggers

A trigger is a statement that is executed automatically by the system as a side effect of a modification to the database.

- Specify the conditions under which the trigger is to be executed.
- Specify the actions to be taken when the trigger executes.

**Example**

**create trigger** timeslot_check **after insert on** section

**referencing new row as** nrow

**for each row**

**when** (nrow.time_slot_id **not in** (select time_slot_id from time_slot))

**begin**

​	**rollback**

**end**;

#### Trigger Events and Actions

- event: insert, delete or update
  - referencing **old** row as: for deletes and updates
  - referencing **new** row as: for inserts and updates

#### Example

**create trigger** credits_earned **after update of** takes **on** (grade)

**referencing new row as** nrow

**referencing old row as** orow

**for each row**

**when** nrow.grade!='F' **and** nrow.grade **is not null**

​	**and** (orow.grade='F' **or** orow.grade **is null**)

**begin atomic**

​	**update** student

​	**set** tot_cred=totcred+

​							(**select** credits

​							**from** course

​							**where** course.courese_id=nrow.course_id)

​	**where** student.id=norw.id;

**end**

#### Statement Level Triggers

- Use **for each statement** instead of **for each row**
- Use **referencing old table** or **referencing new table**



### Chapter 6: Formal Relational Query Languages

#### Relational Algebra

Six basic operators:

- select: $$\sigma$$
- project: $$\Pi$$
- union: $$\cup$$
- set difference: $$-$$
- Cartesian product: $$\times$$
- rename: $$\rho$$

#### Select Operation

- $$\sigma_p(r)= \{ t|t \in r\  and \ p(t) \}$$
- p is the **selection predicate**

#### Project Operation

- $$\Pi_{A_1,A_2,...A_k}(r)$$, where $$A_1,A_2$$ are attribute names and r is a relation name
- **Duplicate rows removed from result**, since relations are sets

#### Union Operation

- $$r \ \cup \ s= \{ t| \ t \in r \ or \ t \in s \}$$
- r, s must be the same arity(same number of attributes)
- The attribute domains must be compatible

#### Set difference of two relations

- $$r \ - \ s= \{ t| \ t \in r \ or \ t \not \in s \}$$
- The same as the above

#### Cartesian product

- $$ r \times s= \{ tq \ | \ t \in r \ and \ q \in s  \}$$

#### Rename Operation

- $$  \rho_{\times}(E) $$ returns the repression E under the name X

**Example**

Find the largest salary in the university.

1. Find instructor salaries that are less than some other instructor salary.

   $$\Pi_{instructor.salary}(\sigma_{instructor.salary<d.salary}(instructor \times \rho_{d}(instructor)))$$

2. Find the largest salary.

   $$\Pi_{salary}(instructor)-\Pi_{instructor.salary}(\sigma_{instructor.salary<d.salary} \\(instructor \times \rho_{d}(instructor)))$$

#### Additional Operations

- Set intersection
- Natural join
- Assignment
- Outer join

#### Set-Intersection Operation

- $$r \ \cap \ s= \{ t| \ t \in r \ and \ t \in s \}$$
- $$r \ \cap \ s=r-(r-s)$$

#### Natural-Join Operation

- $$r \Join s$$

#### Theta Join

$$r \Join_{\theta} s=\sigma_{\theta} (r \times s)$$

#### Assignment Operation

$$\leftarrow$$ provides a convenient way to express complex queries.

#### Outer join

- Left outer join: $$ ^{\_}_{\_} \Join$$
- Right outer join: $$  \Join ^{\_} _{\_}$$
- Full outer join

#### Null values

- *null* signifies an unknown value or that a value does not exist.
- The result of any arithmetic expression involving *null* is null.
- Two *null* are assumed to be the same.

- NOT: (**not **unknown) = unknown

#### Division Operations

Given relation r(R) and r(S), such that $$S \subset R$$,  $$r \div s$$ is the largest relation t(R-S) such that
$$
t \times s \subseteq r
$$
**Example**

let $$r(ID,course\_id)=\Pi_{ID,course\_id}(takes)$$ and $$s(course\_id)=\Pi_{course\_id}(\sigma_{dept\_name='Biology'(course)})$$

then $$r \div s$$ gives us students who have taken all courses in the Biology department.

**Notion**

Can write $r\div s$ as 
$$
temp1 \leftarrow \Pi_{R-S}(r)\\
temp2 \leftarrow \Pi_{R-S}((temp1 \times s)-\Pi_{R-S,S}(r))\\
result \leftarrow temp1-temp2
$$

#### Extended Relational-Algebra-Operations

- Generalized Projection
- Aggregate Functions

#### Generalized Projection

Extends the projection operation by allowing arithmetic functions to be used in the projection list.
$$
\Pi_{F_1,F_2,...F_n}(E)
$$
*E* is any relational-algebra expression

Each of $$F_1,F_2,...F_n$$ are an arithmetic expressions involving constants and attributes in the schema of *E*.

**Example**

Given relation *instructor(ID, name, dept_name, salary)* where salary is annual salary, get the same information but with monthly salary:
$$
\Pi_{ID, name,dept\_name,salary/12}(instructor)
$$

#### Aggregate Functions and Operations

**Aggregate function** takes a collection of values and returns a single value as a result.

- **avg**: average value
- **min**: minimum value
- **max**: maximum value
- **sum**: sum of values
- **count**: number of values

**Aggregate operation** in relational algebra:
$$
_{G_1,G_2,...,G_n} G'_{F_1(A_1)，F_2(A_2),...F_n(A_n)}(E)
$$
*G'* is a notion that I cannot write.

- E is any relational-algebra expression
- $$G_1,G_2,...,G_n$$ is a list of attributes on which to group(can be empty)
- Each $$F_i$$ is an aggregate function
- Each $$A_i$$ is an attribute name

**Example**

Find the average salary in each deparment.
$$
_{dept\_name}G'_{avg(salary)}(instructor)
$$

#### Aggregate Functions (Cont.)

- Result of aggregation does not have a name

- Can use rename operation to give it a name:
  $$
  _{dept\_name}G'_{avg(salary)\  as \ avg\_sal}(instructor)
  $$

#### Modification of the Database

- Deletion
- Insertion
- Updating

All these operations can be expressed using the assignment operator.

#### Multiset Relational Algebra

- Pure relational algebra removes all duplicates

  e.g. after projection

- Multiset relational algebra retains duplicates, to match SQL semantics

- Multiset relational algebra defined as follows

  1. selection: has as may duplicates as a tuple as in the input, if the tuple satisfies the selection
  2. projection: one tuple per input tuple, even if it is a duplicate
  3. cross product: If there are *m* copies of *t1* in *r*, and *n* copies of *t2* in *s*, there are $$m \times n $$ copies of *t1.t2* in $$r \times s $$
  4. Other operations similarly defined

#### SQL and Relational Algebra

##### 1

**select** A1, A2, **sum**(A3)

**from** r1, r2, ..., rm

**where P** 

**group by** A1,A2

is equivalent to the following expression in multiset relational algebra
$$
_{A1,A2} G'_{sum(A3)}( \sigma_P(r1 \times r2 \times ... \times rm))
$$

##### 2

**select** A1,  **sum**(A3) 

**from** r1, r2, ..., rm

**where P** 

**group by** A1,A2

is equivalent to the following expression in multiset relational algebra
$$
_{A1} G'_{sum(A3)}( \sigma_P(r1 \times r2 \times ... \times rm))
$$


### Chapter 7: Entity-Relationship Model

#### Modeling

- A database can be modeled as:
  - A collection of entities
  - Relationship among entities
- An **entity set** is a set of entities of the same type that share the same properties

#### Relationship sets

- A **relationship** is an association among several entities.

- A **relationship set** is a mathematical relation among $$n \geq 2$$ entities, each taken from entity sets
  $$
  \{(e_1,e_2,...e_n)\ |\ e_1 \in E_1,e_2 \in E_2,...,e_n \in E_n \}
  $$
  where $$(e_1,e_2,...e_n)$$ is a relationship.

  **Example**

  $$(44553,22222) \in advisor$$

- An attribute can also be property of a relationship set.

#### Degree of a Relationship Set

- **binary relationship**
  - involve two entity sets(or degree two)
  - most relationship sets in a database system are binary

#### Attributes

- An entity is represented by a set of attributes, that is descriptive properties possessed by all members of an entity set.

  **Example**

  1. instructor=(ID, name, street, city, salary)
  2. course=(course_id, title, credits)

- **Domain**: the set of permitted values for each attribute

- Attribute types:

  1. Simple and composite attributes
  2. Singe-valued and multivalued attributes
  3. Derived attributes: age given date_of_birth

#### Mapping Cardinality Constraints

- Express the number of entities to which another entity can be associated via a relationship set.
- Most useful in describing **binary relationship sets**.
- For a binary relationship set:
  - One to one
  - One to many
  - Many to one
  - Many to many

#### Keys

- A **super key** of an entity set is a set of one or more attributes whose values uniquely determine each entity.
- A **candidate key** of an entity set is a minimal super key.
  - *ID* is candidate key of *instructor*
  - *course_id* is candidate key of *course*
- One of the candidate keys is selected to be the **primary key**.

#### Keys for Relationship Sets

- The combination of primary keys of the participating entity sets forms a super key of a relationship set.

  - (*s_id, i_id*) is the super key of advisor

  - *NOTE*: this means **a pair of entity sets can have at most one relationship in a particular relationship set**.

    Example: if we wish to track multiple meeting dates between a student and her advisor, we cannot assume a relationship for each meeting. We can use a multivalued attribute though.

- Must consider the mapping cardinality of the relationship set when deciding what are the candidate keys

#### Redundant attributes

- The attribute replicates information present in the relationship, and should be removed from *instructor*
- BUT: when converting back to tables, in some cases the attribute gets reintroduced.

#### E-R Diagrams

![img](file:///C:\Users\12094\AppData\Roaming\Tencent\Users\1209497940\QQ\WinTemp\RichOle\J%A}H`9USP7D6CF``X_USRN.png)

- Rectangles represent entity sets.
- Diamonds represent relationship sets.
- Attribute listed inside entity rectangle
- Underline indicates primary key attributes

#### Relationship Sets with Attributes

<img src='https://z3.ax1x.com/2021/06/24/RMZYVK.png'>

#### Roles

<img src='https://z3.ax1x.com/2021/06/24/RMeueP.png'>

- The labels "*course_id*" and "*prereq_id*" is called **roles**.

#### Cardinality Constraints

- a directed line($$\to$$), signifying one
- an undirected line(-), signifying many

#### One-to-One Relationship

<img src='https://z3.ax1x.com/2021/06/24/RMehFO.png'>

#### One-to-Many Relationship

<img src='https://z3.ax1x.com/2021/06/24/RMeTld.png'>

#### Many-to-One Relationship

#### Many-to-Many Relationship

#### Participation of an entity set in a Relationship set

- Total participation (indicated by double line): every entity in the entity set participated in at least one relationship in the relationship set

- Partial participation: some entities may not participate in any relationship set

  <img src='https://z3.ax1x.com/2021/06/24/RMulFK.png'>

#### Alternative Notation for Cardinality Limits

Cardinality limits can also express participation constraints.

<img src='https://z3.ax1x.com/2021/06/24/RMuTl4.png'>

#### E-R Diagram with a ternary relationship

<img src='https://z3.ax1x.com/2021/06/24/RMKinA.png'>

#### Cardinality constraints on Ternary Relationship

- We allow at most one arrow out of a ternary(or a greater degree) relationship to indicate a cardinality constraint
- If there is more than one arrow, there are two ways of defining the meaning.
  - A ternary relationship R between A, B and C with arrows to B and C could mean
    1. each A entity is associated with a unique entity from B and C
    2. each pair of entities from (A, B) is associated with a unique C entity, and each pair (A, C) is associated with a unique B
  - To avoid confusion we outlaw more than one arrow

#### Weak Entity Sets

- An entity set that does not have a primary key is referred to as a **weak entity set**.
- The existence of a weak entity set depends on the existence of a **identifying entity set**
  - It must relate to the identifying set via a total, one-to-many relationship set from the identifying to the weak entity set
  - **identifying relationship** depicted using a double diamond
- The **discriminator**(or *partial key*) of a weak entity set is the set of attributes that distinguishes all the entities of a weak eneity set

<img src='https://z3.ax1x.com/2021/06/24/RMGbod.png'>

- We underline the discriminator of a weak entity set with a **dashed line**.
- We put the identifying relationship in a **double** diamond.
- Primary key for section -(*course_id, sec_id, semester, year*)

#### E-R Diagram for a University Enterprise

<img src='https://z3.ax1x.com/2021/06/24/RMJKw4.png'>

#### Reduction to Relational Schemas

- Entity sets and relationship sets can be expressed uniformly as relation schemas that represent the contents of the database.
- For each entity set and relationship set there is a unique schema that is assigned the name of the corresponding entity set or relationship set.

#### Representing entity sets with simple attributes

- A strong entity set reduces to a schema with the same attributes:

  *student(<u>ID</u>, name, tot_cred)*

- A weak entity set becomes a table that includes a column for the primary key of the identifying strong entity set

  *section(<u>course_id, sec_id, semester, year</u>*)

#### Represent Relationship Sets

- A many-to-many relationship set is represented as a schema with attributes for the primary keys of the two participating entity sets, and any descriptive attributes of the relationship set.

  Example: schema for relationship set *advisor*

  *advisor = (<u>s_id, i_id</u>)*

  <img src='https://z3.ax1x.com/2021/06/24/RMUHPJ.png'>

#### Redundancy of schemas

- Many-to-one and one-to-many relationship sets that are total on the many-side can be represented by adding an extra attribute to the "many" side, containing the primary key of the "one" side.
- For one-to-one relationship sets, either side can be chosen to act as the "many" side.
- If participation is *partial* on the "many" side, replacing a schema by an extra attribute in the schema corresponding to the "many" side could result in null values
- No need for weak entity set.

#### Composite and Multivalued Attributes

- Composite attributes are flattened out by creating a separate attribute for each component attribute
- A multivalued attribute *M* of an entity *E* is represented by a separate schema *EM*
  - Schema *EM* has attributes corresponding to the primary key of *E* and an attribute corresponding to multivalued attribute *M*

#### Converting Non-Binary Relationships to Binary Form

In general, any non-binary relationship can be represented using binary relationships by creating an artificial entity set.

<img src='https://z3.ax1x.com/2021/06/24/RMDFD1.png'>

#### Extended ER Features

Just Know It.



### Chapter 8: Relational Database Design

Denote as a **functional dependency**:
$$
dept\_name \to building,budget
$$
Not all decompositions are good. This is a **lossy decomposition**.

#### First Normal Form

Domain is **atomic** if its elements are considered to be indivisible units. 

Example of non-atomic domains:

- Set of names, composite attributes
- Identification numbers like CS101 that can be broken up into parts

A relation schema R is in **first normal form** if the domains of all attributes of R are atomic.

- Atomicity is actually a property of how the elements of the domain are used.

#### Goal - Devise a Theory for the Following

- Decide whether a particular relation *R* is in good form.

- In the case that a relation *R* is not in good form, decompose it into a set of relations $$\{ R_1,R_2,...,R_n\}$$ such that

  - each relation is in good form
  - the decomposition is a lossless-join decomposition

- Our theory is based on:

  Functional dependencies

  Multivalued dependencies

#### Functional Dependencies

> - Constrains on the set of legal relations
> - Require that the value for a certain set of attributes determines uniquely the value of another set of attributes
> - A functional dependency is a generalization of the notion of a *key*

Let R be a relation schema 
$$
\alpha \subseteq R \ and \ \beta \subseteq R
$$
The **functional dependency**
$$
\alpha \to \beta
$$
**holds on** *R* if and only if for any legal relations *r(R)*, whenever any two tuples $$t_1$$ and $$t_2$$ of *r* agree on the attributes $$\alpha$$, they also agree on the attributes $$\beta$$. That is,
$$
t_1[\alpha]=t_2[\alpha] \Rightarrow t_1[\beta]=t_2[\beta]
$$
**Example**

Consider *r(A, B)* with the following instance of *r*.

| A    | B    |
| ---- | ---- |
| 1    | 4    |
| 1    | 5    |
| 3    | 7    |

On this instance, $$A \to B$$ does **NOT** hold, but $$B \to A$$ does hold.

#### Functional Dependencies (Cont.)

- *K* is a superkey for relation schema *R* if and only if $$K \to R$$.
- *K* is a candidate key for *R* if and only if
  - $$K \to R$$
  - For no $$\alpha \subset K, \alpha \to R$$

Functional dependencies allow us to express constrains that cannot be expressed using superkeys.

#### Use of Functional Dependencies

We use functional dependencies to:

- test relations to see if they are legal under a given set of functional dependencies.
  1. If a relation *r* is legal under a set *F* of functional dependencies, we say that *r* **satisfies** *F*.
- specify constrains on the set of legal relations.
  1. We say that *F*  **holds on** *R* if all legal relations on *R* satisfy the set of functional dependencies *F*.

**Note**: name $$\to$$ ID does not hold on the *instructor*, but it does satisfy.

#### Functional Dependencies (Cont.)

A functional dependency is **trivial** if it is satisfied by all instances of a relation.

Example:

- $$ID,name \to ID$$
- $$name \to name$$

In general, $$\alpha \to \beta$$ is trivial if $$\beta \subseteq \alpha$$

#### Closure of a Set of Functional Dependencies

Given a set *F* of functional dependencies, there are certain other dependencies that that are logically implied by *F*.

- For example: If $$A \to B$$ and $$B \to C$$, then we can infer that $$A \to C$$.

The set of **all** functional dependencies logically implied by *F* is the **closure** of *F*.

We denote the *closure* of *F* by **$$F^+$$**.

$$F^+$$ is a super set of *F*.

#### Boyce-Codd Normal Form

A relational schema *R* is in BCNF with respect a set *F* of functional dependencies if for all functional dependencies in $$F^+$$ of the form
$$
\alpha \to \beta
$$
where $$\alpha \subseteq R$$ and $$\beta \subseteq R$$, at least one of the following holds:

- $$\alpha \to \beta$$ is trivial ( $$\beta \subseteq \alpha$$)
- $$\alpha$$ is a superkey for R

#### Decomposing a Schema into BCNF

Suppose we have a schema *R* and a non-trivial dependency $$\alpha \to \beta$$ causes a violation of BCNF.

We decompose *R* into:

- $$(\alpha\  \cup \ \beta)$$
- $$(R-(\beta - \alpha))$$

#### BCNF and Dependency Preservation

Constrains, including functional dependencies, are costly to check in practice unless they pertain to only one relation.

If it is sufficient to test only those dependencies on each individual relation of a decomposition in order to ensure that *all* functional dependencies hold, then that decomposition is *dependency preserving*.

- A weaker form-- *third normal form*

#### Third Normal Form

A relation schema *R* is in **third normal form**(**3NF**) if for all:
$$
\alpha \to \beta \ in \ F^+
$$
at least one of the following holds:

- $$\alpha \to \beta$$ is trivial($$\beta \subseteq \alpha$$)

- $$\alpha$$ is a superkey for *R*

- Each attribute *A* in $$\beta - \alpha$$ is contained in a candidate key for *R* 

  (**NOTE**: each attribute may be in a different candidate key)

If a relation is in BCNF, it is in 3NF.

#### Closure of a Set of Functional Dependencies

Given a set *F* of functional dependencies, there are certain other functional dependencies that are logically implied by *F*.
$$
For\ e.g.:If \ A \to B \ and \ B \to C, then \ we \ can \ infer\ that \ A\to C.
$$
The set of **all** functional dependencies logically implied by *F* is the **closure** of *F*.

We denote the closure of *F* by $$F^+$$.

#### Find $$F^+$$

We can find $$F^+$$ by repeatedly applying:

**Armstrong's Axioms**

1. **Reflexivity**: if $$\beta \subseteq \alpha$$, then $$\alpha \to \beta$$
2. **Augmentation**: if $$\alpha \to \beta$$, then $$\gamma \alpha \to \gamma \beta$$
3. **Transitivity**: if $$\alpha \to \beta $$, and $$\beta \to \gamma$$, then $$\alpha \to \gamma$$

**Example**
$$
R=\{A,B,C,G,H,I\} \\
F=\{A \to B \\
A \to C \\
CG \to H \\
CG \to I \\
B \to H\}
$$
Then we can compute:
$$
A \to H \\
CG \to HI \\
AG \to I \\
$$

#### Procedure for Computing $$F^+$$

![image-20210624204508332](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624204508332.png)

#### Additional Rules

- If $$\alpha \to \beta $$ holds and $$\alpha \to \gamma $$ holds, then $$\alpha \to \beta \gamma$$ holds.
- If $$\alpha \to \beta \gamma$$ holds, then $$\alpha \to \beta $$ holds and $$\alpha \to \gamma $$ holds.
- If $$\alpha \to \beta $$ holds and $$\gamma \beta \to \delta $$ holds, then $$\gamma \alpha \to \delta $$ holds.

#### Closure of Attribute Sets

Given a set of attribute $$\alpha$$, define the **closure** of $$alpha$$ **under** *F*(denoted by $$\alpha^+$$) as the set of attributes that are functionally determined by $$\alpha$$ under *F*.

- Algorithm to compute $$\alpha^+$$, the closure of $$\alpha$$ under *F*

  ![image-20210624205100503](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624205100503.png)

**Example**

![image-20210624205409405](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624205409405.png)

#### Uses of Attribute Closure

- Testing for superkey:

  To test if $$\alpha$$ is a superkey, we compute $$\alpha^+$$, and check if $$\alpha^+$$ contains all attributes of *R*.

- Testing functional dependencies:

  To check if a functional dependency $$\alpha \to \beta$$ holds (or, in other words, is in *F*+), just check if $$\beta \subseteq \alpha^+$$

  That is, we compute $$\alpha^+$$ by using attribute closure, and then check if it contains $$\beta$$.

  Is a simple and cheap test, and very useful.

- Computing closure of *F*

  For each $$\gamma \subseteq \alpha$$, we find the closure $$\gamma^+$$, and for each , $$S \subseteq \gamma^+$$, we output a functional dependency $$\gamma \to S$$.

#### Canonical Cover

Sets of functional dependencies may have redundant dependencies that can be inferred from the others:

For example: *A* $$\to$$ *C* is redundant in:  {*A* $$\to$$ *B*,  *B* $$\to$$ *C, A$$\to$$* *C*}.

Intuitively, a **canonical cover** of F is a “minimal” set of functional dependencies equivalent to F, having no redundant dependencies or redundant parts of dependencies .

#### Extraneous Attributes

![image-20210624211007761](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624211007761.png)

#### Testing if an Attribute is Extraneous

![image-20210624211453365](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624211453365.png)

#### Canonical Cover

![image-20210624212031320](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624212031320.png)

#### Lossless-join Decomposition

For the case of $$R=(R_1,R_2)$$, we require that for all possible relations *r* on schema *R*
$$
r=\Pi_{R_1}(r) \times \Pi_{R_2} (r)
$$
A decomposition of *R* into $$R_1$$ and $$R_2$$ is lossless join if at least one of the following dependencies is in $$F^+$$:

- $$R_1 \cap R_2 \to R_1$$
- $$R_1 \cap R_2 \to R_2$$

#### Dependency Preservation

Let $$F_i$$ be the set of dependencies $$F^+$$ that include only attributes in $$R_i$$.

- A decomposition is **dependency preserving**, if 
  $$
  (F_1 \cup F_2 \cup ... \cup F_n)^+ = F^+
  $$

- If it is not, then checking updates for violation of functional dependencies may require joins, which is expensive.

#### Testing for Dependency Preservation

![image-20210624214900341](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624214900341.png)

#### Testing for BCNF

![image-20210624215554060](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624215554060.png)

To check if a relation schema *R* is in BCNF, it suffices to check only the dependencies in the given set *F* for violation of BCNF, rather than checking all dependencies in *F*+.

NOT enough when testing a relation in a decomposition of R.

#### Testing Decomposition for BCNF

To check if a relation $$R_i$$ in a decomposition of *R* is in BCNF.

Either test $$R_i$$  for BCNF with respect to the **restriction** of F to $$R_i$$  (that is, all FDs in F+ that contain only attributes from $$R_i$$ )

Or use the original set of dependencies *F* that hold on *R*, but with the following test:

- ![image-20210624215750649](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624215750649.png)
- ![image-20210624215839728](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624215839728.png)

#### BCNF Decomposition Algorithm

![image-20210624220003451](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624220003451.png)

实际上是把$$R_i$$中违背BC范式的函数依赖$$\alpha \to \beta$$分解成了：

- $$R_i - \beta$$
- $$(\alpha,\beta)$$

所以这种分解也必定是无损分解，因为$$\alpha \to \alpha \beta$$

#### Third Normal Form

There are some situations where

- BCNF is not dependency preserving
- Efficient checking for FD violation on updates is important

Solution: define a weaker normal form, called *Third Normal Form(3NF)*

- There is always a lossless-join, dependency-preserving decomposition into 3NF.

#### Testing for 3NF

- Optimization: Need to check only FDs in *F*, need not check all FDs in $$F^+$$
- Use attribute closure to check for each dependency $$\alpha \to \beta $$, if $$\alpha$$ is a superkey
- ![image-20210624222638489](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624222638489.png)

#### 3NF Decomposition Algorithm

![image-20210624222751507](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624222751507.png)

- Above algorithm ensures:
  - each relation schema $$R_i$$ is in 3NF
  - decomposition is dependency preserving and lossless-join

#### Comparison of BCNF and 3NF

- It is always possible to decompose a relation into a set of relations that are in 3NF such that:
  - the decomposition is lossless
  - the dependencies are preserved
- It is always possible to decompose a relation into a set of relations that are in BCNF such that:
  - the decomposition is lossless
  - it may not be possible to preserve dependencies

#### Design Goals

- Goal for a relational database design is:
  - BCNF.
  - Lossless join.
  - Dependency preservation.
- If we cannot achieve this, we accept one of
  - Lack of dependency preservation 
  - Redundancy due to use of 3NF

#### Multivalued Dependencies

Let *R* be a relation schema and let $$\alpha \subseteq R$$ and $$\beta \subseteq R$$. 

The **multivalued dependency**
$$
\alpha \to \to \beta
$$
holds on *R* if any legal relation *r(R)*, for all pairs of tuples $$t_1$$ and $$t_2$$ in *r* that $$t_1[\alpha]=t_2[\alpha]$$, there exists tuples $$t_3$$ and $$t_4$$ in *r* such that:
$$
t_1[\alpha]=t_2[\alpha]=t_3[\alpha]=t_4[\alpha] \\
t_3[\beta]=t_1[\beta]\\
t_3[R-\beta]=t_2[R-\beta]\\
t_4[\beta]=t_2[\beta]\\
t_4[R-\beta]=t_1[R-\beta]\\
$$
![image-20210624230122520](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624230122520.png)
$$
if \ \alpha \to \beta,\ then \ \alpha \to\to\beta \\
if \ \alpha \to \to \beta,\ NO \ \alpha \to \beta
$$


#### Use of Multivalued Dependencies

We use multivalued dependencies in two ways:

- To test relations to **determine** whether they are legal under a given set of functional and multivalued dependencies
- To specify **constraints** on the set of legal relations. We shall thus concern ourselves *only* with relations that satisfy a given set of functional and multivalued dependencies.

#### Theory of MVDs

From the definition of multivalued dependency, we can derive the following rule:
$$
if \ \alpha \to \beta,\ then \ \alpha \to\to\beta \\
$$
That is, every functional dependency is also a multivalued dependency.

The **closure** $$D^+$$ of *D* is the set of all functional and multivalued dependencies logically implied by *D*. 

- We can compute  $$D^+$$ from *D*, using the formal definitions of functional dependencies and multivalued dependencies.

#### Fourth Normal Form

A relation schema *R* is in **4NF** with respect to a set *D* of functional and multivalued dependencies if for all multivalued dependencies in  $$D^+$$ of the form $$\alpha \to \to \beta$$, where $$\alpha \subseteq R$$ and $$\beta \subseteq R$$, at least one of the following hold:

- $$\alpha \to \to \beta$$ is a trivial multivalued dependency
- $$\alpha$$ is a superkey for schema *R*

If a is in 4NF it is in BCNF.

#### Restriction of Multivalued Dependencies

The restriction of *D* to $$R_i$$ is the set $$D_i$$ consisting of

- All functional dependencies in $$D^+$$ that include only attributes of $$R_i$$

- All multivalued dependencies of the form
  $$
  \alpha \to \to (\beta\  \cap \ R_i)
  $$
  where $$\alpha \subseteq R_i$$ and $$\alpha \to \to \beta$$ is in $$D^+$$.

#### 4NF Decomposition Algorithm

![image-20210624234138654](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210624234138654.png)

### Storage and File Structure

#### Classification of Physical Storage Media

 Can differentiate storage into:

- volatile storage
- non-volatile storage

#### Physical Storage Media

- Cache: fastest and most costly form of storage; volatile; managed by the computer system hardware.
- Main memory:
  - fast access
  - generally too small
  - volatile
- Flash memory:
  - Data survives power failure
  - Reads are roughly as fast as main memory
  - But writes are slow (few microseconds), erase is slower
- Magnetic-disk:
  - Data is stored on spinning disk, and read/written magnetically
  - Data must be moved from disk to main memory for access, and written back for storage
  - **direct-access**
- Optical storage:
  - non-volatile, data is read from a spinning disk using a laser
- Tape storage:
  - non-volatile
  - **sequential-access**

#### Storage Hierarchy

![image-20210625125734460](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625125734460.png)

- Primary Storage: Fastest media but volatile
- Secondary storage: non-volatile, moderately fast access time
- Tertiary storage: non-volatile, slow access time

#### Magnetic Hard Disk Mechanism

![image-20210625130052361](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625130052361.png)

#### Performance Measures of Disks

- Access time: the time it takes from when a read or write request is issued to when data transfer begins
  - Seek time
  - Rotational latency
- Data-transfer rate
- Mean time to failure

#### Optimization of Disk-Block Access

- Block: a contiguous sequence of sectors from a single track 
  - data is transferred between disk and main memory in blocks
- Data-arm-scheduling
- File organization: optimize block access time by organizing the blocks to correspond to how data will be accessed

#### RAID

- **Redundant Arrays of Independent Disks** 

#### File Organization

The database is stored as a collection of *files*. Each file is a sequence of *records.* A record is a sequence of fields.

#### Fixed-Length Records

![image-20210625131810138](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625131810138.png)

#### Free Lists

![image-20210625131843255](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625131843255.png)

#### Variable-Length Records

![image-20210625131928538](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625131928538.png)

### Chapter 11: Indexing and Hashing

#### Basic Concepts

- **Search Key**: attribute or set of attributes used to look up records in a file

- An **index file** consists of records(called **index entries**) of the form:

  ![image-20210625132345940](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625132345940.png)

- Two basic kinds of indices:

  - **Ordered indices**
  - **Hash indices**

#### Ordered indices

In an **ordered index**, index entries are stored sorted on the search key value.

- **Primary index**: in a sequentially ordered file, the index whose search key specifies the sequential order of the file.
  - Also called **clustering index**
  - The search key of a primary index is usually but not necessarily the primary key.
- **Secondary index**: an index whose sear0ch key specifies an order different from the sequential order of the file. Also called **non-clustering index**.
- Index-sequential file: ordered sequential file with a primary index.

#### Dense Index files

**Dense Index**: index record appears for every search-key value in the file.

![image-20210625133810773](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625133810773.png)

#### Sparse Index Files

**Sparse index**: contains index records only for some search-key values.

- Applicable when records are sequentially ordered on search-key

To locate a record with search-key value *K* we:

- Find index record with largest search-key value *< K*
- Search file sequentially starting at the record to which the index record points

![image-20210625134205350](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625134205350.png)

Compared to dense indices:

- Less space and less maintenance overhead for insertions and deletions.
- Generally slower than dense index for locating records.

**Good tradeoff**: sparse index with an index entry for every block in file, corresponding to least seatch-key value in the block:

![image-20210625134339999](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625134339999.png)

#### Secondary Indices Example

![image-20210625134428282](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625134428282.png)

- Index record points to a **bucket** that contains pointers to all the actual records with that particular search-key value.
- Secondary indices have to be dense.

#### Multivalued Index

- If primary index does not fit in memory, access becomes expensive.

- Solution: treat primary index kept on disk as a sequential file and construct a sparse index on it.
  - outer index: a sparse index of primary index
  - inner index: the primary index file

![image-20210625134808076](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625134808076.png)

#### Index Update: Deletion

Single-level index entry deletion:

- Dense indices: deletion of search-key is similar to file record deletion
- Sparse indices:
  - if an entry for the search key exists in the index, it is deleted by replacing the entry in the index with the next search-key value in the file
  - If the next search-key value already has an index entry, the entry is deleted instead of being replaced.

#### Index Update: Insertion

Single-level index insertion:

- Dense indices: if the search-key value does not appear in the index, insert it.
- Sparse indices: if index stores an entry for each block of the file, no change need to be made to the index unless a new block is created.
  - If a new block is created, the first search-key value appearing in the new block is inserted into the index.

#### Secondary indices

We can have a secondary index with an index record for each search-key value

#### $$B^+$$-Tree Index Files

A $$B^+$$-Tree is a rooted tree satisfying the following properties:

- All paths from root to leaf are of the same length.
- Each node that is not a root or a leaf has between $$n/2$$ and *n* children.
- A leaf node has between *(n-2)/2* and *n-1* values
- Special cases:
  - If the root is not a leaf, it has at least 2 children.
  - If the root is a leaf(that is, there are no other nodes in the tree), it can have between 0 and *(n-1)* children.

#### $$B^+$$-Tree Node Structure

Typical node:

![image-20210625141034779](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625141034779.png)

- $$K_i$$ are the search-key values

- $$P_i$$ are pointers to children(for non-leaf nodes) or pointers to records or buckets of records(for leaf nodes)

- The search-keys in a node are ordered:
  $$
  K_1<K_2<K_3<...<K_{n-1}
  $$

#### Leaf Nodes in $$B^+$$-Trees

Properties of a leaf node:

![image-20210625141250585](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625141250585.png)

#### Non-Leaf Nodes in $$B^+$$-Trees

Non leaf nodes form a multi-level sparse index on the leaf nodes. For a non-leaf node with n pointers:

- All the search-keys in the subtree to which $$P_1$$ are less than $$K_1$$
- For $$2 \leq i \leq n-1$$, all the search-keys in the subtree to which $$P_i$$ points have values greater than or equal to $$K_{i-1}$$ and less than $$K_i$$
- All the search-keys in the subtree to which $$P_n$$ points have values greater than or equal to $$K_{n-1}$$

#### B-Tree Index Files

- B-tree allows search-key values to appear only once; eliminates redundant storage of search keys.
- Search keys in nonleaf nodes appear nowhere else in the B-tree; an additional pointer field for each search key in a nonleaf node must be included.

Generalized B-tree leaf node:

![image-20210625145042648](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625145042648.png)

#### Static Hashing

A **bucket** is a unit of storage containing one or more records(a bucket is typically a disk block).

In a **hash file organization** we obtain the bucket of a record directly from its search-key value using a **hash function**.



### Chapter 14: Transactions

#### Transaction Concept

A **transaction** is a *unit* of program execution that accesses and possibly updates various data items.

#### ACID Properties

To preserve the integrity of data the database system must ensure:

- **Atomicity**. Either all operations of the transaction are properly reflected in the database or none are.
- **Consistency**. Execution of a transaction in isolation preserves the consistency of the database.
- **Isolation**. Although multiple transactions may execute concurrently, each transaction must be unware of other concurrently executing transactions.
  - That is, for every pair of transactions $$T_i$$ and $$T_j$$, it appears to $$T_i$$ that either $$T_j$$, finished execution before $$T_i$$ started, or $$T_j$$ started execution after $$T_j$$ finished.
- **Durability**. After a transaction completes successfully, the changes it has made to the database persist, even if there are system failures.

#### Transaction State

- Active
- Partially committed
- Failed
- Aborted
- Committed

![image-20210625154350707](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625154350707.png)

#### Schedules

**Schedules**: a sequences of instructors that specify the chronological order in which instructions of concurrent transactions are executed.

#### Serializability

A schedule is serializable if it is equivalent to a serial schedule. Different forms of schedule equivalence give rise to the notions of:

- conflict serializability
- view serializability

#### Simplified view of transactions

Our simplified schedules consists of only **read** and **write** instructions.

#### Conflicting Instructions

Instructions $$I_i$$ and $$I_j$$ of transactions $$T_i$$ and $$T_j$$ respectively, **conflict** if and only if there exists some item *Q* accessed by both $$I_i$$ and $$I_j$$, and at least one of these instructions wrote *Q*.

#### Conflict Serializability

If a schedule *S* can be transformed into a schedule *S'* by a series of non-conflicting instructions, we say that *S* and *S'* are **conflict equivalent**.

We say that a schedule *S* is **conflict serializable** if it is conflict equivalent to a serial schedule.

#### View Serializability

![image-20210625160102853](C:\Users\12094\AppData\Roaming\Typora\typora-user-images\image-20210625160102853.png)

#### Recoverable Schedules

if a transaction *Tj* reads a data item previously written by a transaction *Ti* , then the commit operation of *Ti*  appears before the commit operation of *Tj*																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																													